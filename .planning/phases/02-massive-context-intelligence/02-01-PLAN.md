---
phase: 02-massive-context-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/intel/ReferenceContextBuilder.js
  - bin/gsd-context.js
autonomous: true
user_setup: []
must_haves:
  truths:
    - "CLI can generate context for a given file"
    - "Context includes Tier 1 (direct) and Tier 2 (recursive) dependencies"
    - "Token budget is respected (soft limit 500k)"
  artifacts:
    - path: "lib/intel/ReferenceContextBuilder.js"
      provides: "Context generation logic"
    - path: "bin/gsd-context.js"
      provides: "CLI interface for context"
  key_links:
    - from: "bin/gsd-context.js"
      to: "lib/intel/ReferenceContextBuilder.js"
      via: "import/require"
---

<objective>
Implement the core `ReferenceContextBuilder` engine and a CLI wrapper. This engine is responsible for intelligently selecting and formatting code context based on the project's dependency graph.

Purpose: Enable the planner to "see" relevant code without dumping the entire repo into the prompt.
Output: `bin/gsd-context.js` executable that outputs formatted context.
</objective>

<execution_context>
@~/.gemini/get-shit-done/workflows/execute-plan.md
@~/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-massive-context-intelligence/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReferenceContextBuilder</name>
  <files>lib/intel/ReferenceContextBuilder.js</files>
  <action>
    Create `lib/intel/ReferenceContextBuilder.js` class.
    
    Logic:
    1. constructor: Accept `dbPath` (default to `.planning/intel/graph.db`).
    2. `init()`: Load `sql.js` database.
    3. `getDependencies(file, depth)`: Execute the Recursive CTE query defined in RESEARCH.md.
       - Base case: Direct imports.
       - Recursive: Imports of imports.
       - Return: List of file paths.
    4. `buildContext(targetFile)`:
       - Fetch dependencies (Tier 1 & 2).
       - Read file contents for target + dependencies.
       - Apply token budgeting (soft limit 500k).
       - Format as XML:
         ```xml
         <reference_context>
           <file path="...">...</file>
         </reference_context>
         ```
  </action>
  <verify>
    Create a temporary test script that imports ReferenceContextBuilder, mocks a DB or uses existing one, and prints context for a known file.
  </verify>
  <done>Class exists and `buildContext` returns formatted string.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI Wrapper</name>
  <files>bin/gsd-context.js</files>
  <action>
    Create `bin/gsd-context.js` as a standalone executable.
    
    Usage: `node bin/gsd-context.js <target-file>`
    
    Logic:
    1. Parse argument (target file path).
    2. Instantiate `ReferenceContextBuilder`.
    3. Call `buildContext`.
    4. Output result to stdout.
    5. Handle errors gracefully (e.g., DB not found -> return empty context or warning).
  </action>
  <verify>
    Run `node bin/gsd-context.js bin/gsd-watch.js` (or any existing file) and check output.
  </verify>
  <done>CLI command outputs context XML.</done>
</task>

</tasks>

<verification>
- [ ] `lib/intel/ReferenceContextBuilder.js` implements recursive CTE.
- [ ] `bin/gsd-context.js` is executable.
- [ ] Output is wrapped in `<reference_context>` tags.
</verification>

<success_criteria>
- Context engine works independently.
- Can be called by other tools/scripts.
</success_criteria>

<output>
After completion, create `.planning/phases/02-massive-context-intelligence/02-01-SUMMARY.md`
</output>
